// Generated by scripts/generate-theme-tokens.ts. Do not edit directly.
import rawTokens from "./theme.tokens.json";
import { z } from "zod";

export type CSSVariableName = `--${string}`;

export type ThemeTokenCategory = "surface" | "text" | "border" | "brand" | "feedback" | "typography" | "radius" | "shadow" | "ring" | "glass" | "card" | "dock" | "presence" | "layout" | "spacing" | "motion" | "utility";

export type ThemeTokenValueKind = "color" | "gradient" | "shadow" | "fontFamily" | "radius" | "dimension" | "time" | "timingFunction" | "other";

export type ThemeTokenLayer = "foundation" | "semantic" | "component" | "utility";

type TailwindGroup =
  | "colors"
  | "borderRadius"
  | "fontFamily"
  | "boxShadow"
  | "backgroundImage"
  | "spacing"
  | "transitionDuration"
  | "transitionTimingFunction";

const TokenSchema = z.object({
  id: z.string(),
  label: z.string(),
  cssVar: z.string().regex(/^--/),
  category: z.enum(["surface","text","border","brand","feedback","typography","radius","shadow","ring","glass","card","dock","presence","layout","spacing","motion","utility"]),
  valueKind: z.enum(["color","gradient","shadow","fontFamily","radius","dimension","time","timingFunction","other"]),
  description: z.string().optional(),
  tags: z.array(z.string()).default([]),
  semantics: z.string().optional(),
  layer: z.enum(["foundation","semantic","component","utility"]),
  surfaces: z.array(z.string()).optional(),
  fallback: z.string(),
  lightFallback: z.string().optional(),
  aliases: z.array(z.string()).optional(),
  exposeToStyler: z.boolean().optional(),
  tailwind: z
    .object({
      path: z.array(z.string()).min(2),
    })
    .optional(),
});

export type ThemeTokenDefinition = z.infer<typeof TokenSchema>;

export type ThemeTokenId = ThemeTokenDefinition["id"];
export type ThemeTokenCssVar = ThemeTokenDefinition["cssVar"];

const tokens = TokenSchema.array().parse(rawTokens);

export const themeTokenRegistry = tokens;

export type ThemeTokenMeta = {
  readonly id: ThemeTokenId;
  readonly cssVar: ThemeTokenCssVar;
  readonly category: ThemeTokenCategory;
  readonly valueKind: ThemeTokenValueKind;
  readonly label: string;
  readonly tags: readonly string[];
  readonly layer: ThemeTokenLayer;
};

const THEME_TOKEN_META_ENTRIES = tokens.map(
  (token) =>
    [
      token.cssVar,
      {
        id: token.id as ThemeTokenId,
        cssVar: token.cssVar as ThemeTokenCssVar,
        category: token.category,
        valueKind: token.valueKind,
        label: token.label,
        tags: token.tags ?? [],
        layer: token.layer,
      },
    ] as const,
);

export const themeTokenMetaByCssVar = Object.freeze(
  Object.fromEntries(THEME_TOKEN_META_ENTRIES),
) as unknown as Record<ThemeTokenCssVar, ThemeTokenMeta>;

export const themeTokensById: ReadonlyMap<ThemeTokenId, ThemeTokenDefinition> = new Map(
  tokens.map((token) => [token.id as ThemeTokenId, token]),
);

export const themeTokensByCssVar: ReadonlyMap<ThemeTokenCssVar, ThemeTokenDefinition> = new Map(
  tokens.map((token) => [token.cssVar as ThemeTokenCssVar, token]),
);

export const THEME_TOKEN_CSS_VARS = new Set<ThemeTokenCssVar>(
  tokens.map((token) => token.cssVar),
);

export const STYLER_THEME_TOKEN_CSS_VARS = new Set<ThemeTokenCssVar>(
  tokens.filter((token) => token.exposeToStyler !== false && token.layer !== "component").map((token) => token.cssVar as ThemeTokenCssVar),
);

export type TailwindThemeExtension = Partial<Record<TailwindGroup, Record<string, unknown>>>;

export function buildTailwindThemeExtension(
  registry: readonly ThemeTokenDefinition[] = tokens,
): TailwindThemeExtension {
  const extend: TailwindThemeExtension = {};
  for (const token of registry) {
    const binding = token.tailwind;
    if (!binding) continue;
    const [group, ...path] = binding.path;
    if (!path.length) continue;
    const base = (extend[group as TailwindGroup] ??= {});
    let cursor: Record<string, unknown> = base;
    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i]!;
      const next = cursor[key];
      if (typeof next === "object" && next !== null) {
        cursor = next as Record<string, unknown>;
      } else {
        const fresh: Record<string, unknown> = {};
        cursor[key] = fresh;
        cursor = fresh;
      }
    }
    const leafKey = path[path.length - 1]!;
    cursor[leafKey] = `var(${token.cssVar})`;
  }
  return extend;
}

export function isThemeTokenVar(input: string): input is ThemeTokenCssVar {
  return THEME_TOKEN_CSS_VARS.has(input as ThemeTokenCssVar);
}

export function asCssVar(value: ThemeTokenCssVar): string {
  return `var(${value})`;
}

export const tailwindThemeExtension = buildTailwindThemeExtension();

const CONTEXTUAL_TOKEN_PREFIXES: readonly string[] = [
  "home.",
  "friends.",
  "chats.",
  "requests.",
  "party.",
  "prompter.",
  "surface.style.",
  "text.style.",
  "shadow.style.",
  "border.style.",
  "surface.friends.",
  "text.friends.",
  "border.friends.",
  "shadow.friends.",
  "surface.chats.",
  "text.chats.",
  "border.chats.",
  "shadow.chats.",
  "surface.party.",
  "text.party.",
  "border.party.",
  "shadow.party.",
  "surface.create.",
  "text.create.",
  "border.create.",
  "shadow.create.",
  "surface.settings.",
  "text.settings.",
  "border.settings.",
  "shadow.settings.",
  "surface.tile.",
  "text.tile.",
  "border.tile.",
  "shadow.tile.",
  "surface.studio.",
  "text.studio.",
  "border.studio.",
  "shadow.studio.",
  "ring.studio.",
  "surface.store.",
  "text.store.",
  "border.store.",
  "shadow.store.",
];

const isContextualToken = (token: ThemeTokenDefinition): boolean =>
  CONTEXTUAL_TOKEN_PREFIXES.some((prefix) => token.id.startsWith(prefix));

export const coreSiteThemeTokens = tokens.filter(
  (token) => token.layer !== "component" && !isContextualToken(token),
);

export const CORE_SITE_THEME_TOKEN_IDS = coreSiteThemeTokens.map(
  (token) => token.id as ThemeTokenId,
);

export const CORE_SITE_THEME_TOKEN_SET = new Set<ThemeTokenId>(CORE_SITE_THEME_TOKEN_IDS);

export const CORE_SITE_THEME_TOKEN_CSS_VARS = new Set<ThemeTokenCssVar>(
  coreSiteThemeTokens.map((token) => token.cssVar as ThemeTokenCssVar),
);
