-- Capsules schema additions for Polls and Voting
-- Run these statements in Supabase SQL editor.

-- 1) Add poll JSONB column on posts to store question + options
ALTER TABLE public.posts
ADD COLUMN IF NOT EXISTS poll JSONB;

-- 2) Poll votes table (one vote per user per poll)
-- Recommended if your posts primary key is BIGINT (numeric) and you also store
-- a client-generated ID in posts.client_id.
CREATE TABLE IF NOT EXISTS public.poll_votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  post_id BIGINT NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  option_index INTEGER NOT NULL CHECK (option_index >= 0),
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE (post_id, user_id)
);

-- If your posts table instead uses TEXT/UUID as primary key and does NOT have a
-- numeric id, replace the table above with the TEXT variant below (comment out
-- the one above and uncomment this block):
--
-- CREATE TABLE IF NOT EXISTS public.poll_votes (
--   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   post_id TEXT NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
--   user_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
--   option_index INTEGER NOT NULL CHECK (option_index >= 0),
--   created_at TIMESTAMPTZ DEFAULT now(),
--   UNIQUE (post_id, user_id)
-- );

-- 3) RLS policies (backend uses service_role)
ALTER TABLE public.poll_votes ENABLE ROW LEVEL SECURITY;
DO $$ BEGIN
  CREATE POLICY "Service role full access" ON public.poll_votes
    TO service_role USING (true) WITH CHECK (true);
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 4) Optional: indexes for aggregation speed
CREATE INDEX IF NOT EXISTS idx_poll_votes_post_id ON public.poll_votes(post_id);
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns
             WHERE table_schema = 'public' AND table_name = 'poll_votes' AND column_name = 'user_id') THEN
    CREATE INDEX IF NOT EXISTS idx_poll_votes_user_id ON public.poll_votes(user_id);
  ELSIF EXISTS (SELECT 1 FROM information_schema.columns
                WHERE table_schema = 'public' AND table_name = 'poll_votes' AND column_name = 'user_key') THEN
    CREATE INDEX IF NOT EXISTS idx_poll_votes_user_key ON public.poll_votes(user_key);
  END IF;
END $$;

-- 5) (Optional) If you want to expose poll counts via a view
-- This view returns option_index and vote count per post id
CREATE OR REPLACE VIEW public.poll_vote_counts AS
SELECT post_id, option_index, COUNT(*)::INT AS votes
FROM public.poll_votes
GROUP BY post_id, option_index;

-- 6) Soft delete support for posts and comments
ALTER TABLE public.posts
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;

ALTER TABLE public.comments
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_posts_deleted_at ON public.posts(deleted_at);
CREATE INDEX IF NOT EXISTS idx_comments_deleted_at ON public.comments(deleted_at);

-- 7) Ownership column for posts to enforce author-only deletes (optional)
ALTER TABLE public.posts
ADD COLUMN IF NOT EXISTS author_user_id UUID REFERENCES public.users(id) ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_posts_author_user ON public.posts(author_user_id);

-- Create memories table to store assets and descriptions (Pinecone holds vector data)
CREATE TABLE IF NOT EXISTS public.memories (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  owner_user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
  kind TEXT CHECK (kind IN ('upload','generated','post','theme')) DEFAULT 'upload',
  title TEXT,
  description TEXT,
  media_url TEXT,
  media_type TEXT,
  post_id TEXT,
  meta JSONB,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_memories_owner ON public.memories(owner_user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memories_kind ON public.memories(kind);
-- Vector indexes (HNSW/IVFFlat) are intentionally omitted.
-- Pinecone handles semantic recall in production and removes write overhead here.

-- RLS
ALTER TABLE public.memories ENABLE ROW LEVEL SECURITY;
DO $$ BEGIN
  CREATE POLICY "Service role full access" ON public.memories TO service_role USING (true) WITH CHECK (true);
EXCEPTION WHEN duplicate_object THEN NULL; END $$;
-- You can tighten read access later when mapping auth to users
DO $$ BEGIN
  CREATE POLICY "Authenticated read own" ON public.memories FOR SELECT TO authenticated USING (true);
EXCEPTION WHEN duplicate_object THEN NULL; END $$;


-- Legacy memory_items upgrade (ensures older table stores media details)
DO 
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema = 'public' AND table_name = 'memory_items'
  ) THEN
    BEGIN
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS media_url TEXT;
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS media_type TEXT;
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS title TEXT;
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS description TEXT;
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS kind TEXT DEFAULT 'upload';
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT now();
      ALTER TABLE public.memory_items ADD COLUMN IF NOT EXISTS meta JSONB;
    EXCEPTION WHEN duplicate_column THEN NULL;
    END;
  END IF;
END;
